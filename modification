// ---- NORMALISATION DES COLONNES NOT NULL (à mettre juste avant prepared.Add(row)) ----
var meta = GetColumnsMetaCached(tableName);

// on parcourt les colonnes réellement insérées (donc hors identity)
foreach (var col in columnNames)
{
    if (hasIdentity && col.Equals(identityColumn, StringComparison.OrdinalIgnoreCase)) continue;
    if (!row.ContainsKey(col)) continue;
    if (!meta.TryGetValue(col, out var m)) continue;   // méta absente -> on n’insiste pas
    if (m.IsComputed) continue;                        // colonnes calculées : ne jamais fournir

    var s = (row[col] ?? "").ToString();
    var isNullish = string.IsNullOrWhiteSpace(s) || s.Equals("NULL", StringComparison.OrdinalIgnoreCase);

    if (isNullish && !m.IsNullable)
    {
        // 1) si la colonne a un DEFAULT simple (constante), on l’utilise
        if (TryParseSimpleDefault(m.ColumnDefault, out var defVal))
        {
            row[col] = defVal; // BuildValuesBatch gèrera le quoting selon le type (string/object)
        }
        else
        {
            // 2) sinon, fallback “raisonnable” selon le type pour éviter l’échec d’INSERT
            row[col] = GetTypeFallback(m.DataType);
        }
    }
    else if (isNullish)
    {
        // colonne nullable -> NULL explicite
        row[col] = null;
    }
}
// ---- fin normalisation ----