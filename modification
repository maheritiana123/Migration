public void PerformMigration()
{
    Console.WriteLine("=== Début migration ===");

    // 1) Récupérer l'ordre d'import (tables filtrées + triées par dépendances)
    var importOrder = SortTablesByDependencies(GetAllTables());

    foreach (var table in importOrder)
    {
        try
        {
            ImportTableCommon(table);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Erreur sur {table} : {ex.Message}");
        }
    }

    // Optionnel : si tu as des tables relationnelles étendues à gérer après
    foreach (var relTable in _extendedRelationTables)
    {
        try
        {
            ImportTableCommon(relTable, forceNullFK: false);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Erreur sur {relTable} : {ex.Message}");
        }
    }

    Console.WriteLine("=== Migration terminée ===");
}

private void ImportTableCommon(string tableName, bool forceNullFK = false)
{
    Console.WriteLine($"Import table {tableName}");

    string csvPath = Path.Combine(_importPath, $"Export_Migration_{tableName}_{Environment.GetEnvironmentVariable("PFTLSITE")}.csv");
    if (!File.Exists(csvPath))
    {
        Console.WriteLine($"⚠ CSV introuvable : {tableName}");
        return;
    }

    var lines = File.ReadAllLines(csvPath);
    if (lines.Length < 2)
    {
        Console.WriteLine($"⚠ CSV vide : {tableName}");
        return;
    }

    var columnNames = lines[0].Split(';').Select(c => c.Trim()).ToList();
    var identityColumn = GetIdentityColumn(tableName);
    var fkInfos = GetForeignKeyInfo(tableName);

    bool hasIdentity = !string.IsNullOrEmpty(identityColumn);
    int insertedCount = 0, duplicateCount = 0;

    var batchLines = new List<string>();
    int batchSize = 100;

    for (int i = 1; i < lines.Length; i++)
    {
        var values = lines[i].Split(';').ToList();
        if (values.Count != columnNames.Count) continue;

        var rowDict = columnNames.Zip(values, (col, val) => new { col, val })
                                 .ToDictionary(x => x.col, x => (object)x.val);

        string oldId = null;
        if (hasIdentity && rowDict.ContainsKey(identityColumn))
        {
            oldId = (rowDict[identityColumn] ?? "").ToString();
            rowDict.Remove(identityColumn);
        }

        foreach (var fk in fkInfos)
        {
            if (!rowDict.ContainsKey(fk.ColumnName)) continue;
            if (forceNullFK) { rowDict[fk.ColumnName] = null; continue; }

            var oldFkValue = (rowDict[fk.ColumnName] ?? "").ToString();
            if (string.IsNullOrWhiteSpace(oldFkValue))
            {
                rowDict[fk.ColumnName] = null;
                continue;
            }

            if (_idMappings.TryGetValue(fk.ReferencedTableName, out var map) &&
                map.TryGetValue(oldFkValue, out var newFkValue))
            {
                rowDict[fk.ColumnName] = newFkValue;
            }
            else if (IsForeignKeyNullable(fk))
            {
                rowDict[fk.ColumnName] = null;
            }
            else
            {
                throw new Exception($"Mapping manquant pour FK {fk.ColumnName} → {fk.ReferencedTableName}");
            }
        }

        var tokens = rowDict.Select(kv => FormatValueForSql(kv.Value, GetColumnType(tableName, kv.Key))).ToList();
        batchLines.Add(string.Join(((char)31).ToString(), tokens));

        if (batchLines.Count >= batchSize || i == lines.Length - 1)
        {
            DynamicSql sql = new DynamicSql { Dsn = "PXE1_PXE" };
            string request = @"EXEC [dbo].[batch_safe_insert_with_type_conversion] 
                @TableName = $table$,
                @Columns = $cols$,
                @ValuesBatch = $valsBatch$,
                @HasIdentity = $identity$,
                @IdentityCol = $idCol$";

            sql.AddDirectRequest(request, MidwSqlXmlMode.MIDW_SQL_XMLMODE_RAW);
            sql.SetSecureParam("table", tableName, true, 0);
            sql.SetSecureParam("cols", string.Join(",", rowDict.Keys.Select(c => $"[{c}]")), true, 0);
            sql.SetSecureParam("valsBatch", string.Join(((char)30).ToString(), batchLines), true, 0);
            sql.SetSecureParam("identity", hasIdentity ? 1 : 0, true, 0);
            sql.SetSecureParam("idCol", identityColumn ?? "", true, 0);

            sql.Execute();

            if (hasIdentity)
            {
                for (int r = 1; r <= sql.ReturnedRows(1, 1); r++)
                {
                    string newId = sql.GetValueUsingColName(r, "NewID", 1, 1);
                    string oldIdMapped = sql.GetValueUsingColName(r, "OldID", 1, 1);

                    if (!string.IsNullOrEmpty(newId) && !string.IsNullOrEmpty(oldIdMapped))
                    {
                        if (!_idMappings.ContainsKey(tableName))
                            _idMappings[tableName] = new Dictionary<string, string>();

                        _idMappings[tableName][oldIdMapped] = newId;
                    }
                }
            }

            batchLines.Clear();
        }
    }

    Console.WriteLine($"✅ Table {tableName} importée.");
}

IF OBJECT_ID(N'[dbo].[batch_safe_insert_with_type_conversion]', N'P') IS NOT NULL
    DROP PROCEDURE [dbo].[batch_safe_insert_with_type_conversion];
GO

CREATE PROCEDURE [dbo].[batch_safe_insert_with_type_conversion]
    @TableName      NVARCHAR(128),
    @Columns        NVARCHAR(MAX),       -- ex: [Col1],[Col2],...
    @ValuesBatch    NVARCHAR(MAX),       -- ex: ligne1␞ligne2 (␞ = CHAR(30))
    @HasIdentity    BIT = 0,
    @IdentityCol    NVARCHAR(128) = NULL -- peut être NULL si pas d'identity
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @output TABLE (OldID NVARCHAR(100), NewID INT);
    DECLARE @duplicateCount INT = 0;

    -- Trouver colonne Identity si non fournie
    IF @HasIdentity = 1 AND @IdentityCol IS NULL
    BEGIN
        SELECT TOP 1 @IdentityCol = COLUMN_NAME
        FROM INFORMATION_SCHEMA.COLUMNS
        WHERE TABLE_NAME = @TableName
          AND COLUMNPROPERTY(OBJECT_ID(TABLE_NAME), COLUMN_NAME, 'IsIdentity') = 1;
    END

    -- Colonnes PK/UK hors Identity
    DECLARE @pkCols NVARCHAR(MAX);
    SELECT @pkCols = STRING_AGG(QUOTENAME(c.COLUMN_NAME), ',')
    FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc
    JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE c
        ON tc.CONSTRAINT_NAME = c.CONSTRAINT_NAME
       AND tc.TABLE_NAME = c.TABLE_NAME
    WHERE tc.TABLE_NAME = @TableName
      AND tc.CONSTRAINT_TYPE IN ('PRIMARY KEY', 'UNIQUE')
      AND c.COLUMN_NAME <> ISNULL(@IdentityCol, '');

    -- Boucle sur chaque ligne du batch
    DECLARE @line NVARCHAR(MAX);
    DECLARE line_cursor CURSOR FOR
        SELECT value FROM STRING_SPLIT(@ValuesBatch, CHAR(30)); -- CHAR(30) = séparateur lignes

    OPEN line_cursor;
    FETCH NEXT FROM line_cursor INTO @line;

    WHILE @@FETCH_STATUS = 0
    BEGIN
        DECLARE @Values NVARCHAR(MAX) = '';
        DECLARE @ValueTokens NVARCHAR(MAX) = '';

        -- Split colonnes de la ligne (CHAR(31) = séparateur colonnes)
        DECLARE @colList TABLE (ColName NVARCHAR(128), Ord INT);
        DECLARE @valList TABLE (Val NVARCHAR(MAX), Ord INT);

        INSERT INTO @valList (Val, Ord)
        SELECT value, ROW_NUMBER() OVER (ORDER BY (SELECT NULL))
        FROM STRING_SPLIT(@line, CHAR(31));

        -- Colonnes (déjà connues)
        INSERT INTO @colList (ColName, Ord)
        SELECT LTRIM(RTRIM(REPLACE(REPLACE(value, '[', ''), ']', ''))),
               ROW_NUMBER() OVER (ORDER BY (SELECT NULL))
        FROM STRING_SPLIT(@Columns, ',')
        WHERE RTRIM(LTRIM(value)) <> '';

        -- Reconstruire @Values (séparées par virgule pour INSERT)
        SELECT @Values = STRING_AGG(Val, ',') WITHIN GROUP (ORDER BY Ord)
        FROM @valList;

        -- Vérifier doublon si PK/UK
        DECLARE @whereClause NVARCHAR(MAX) = '';
        IF @pkCols IS NOT NULL AND LEN(@pkCols) > 0
        BEGIN
            SELECT @whereClause = COALESCE(@whereClause + ' AND ', '') +
                CASE WHEN UPPER(v.Val) = 'NULL' THEN QUOTENAME(c.ColName) + ' IS NULL'
                     ELSE QUOTENAME(c.ColName) + ' = ' + v.Val END
            FROM @colList c
            JOIN @valList v ON c.Ord = v.Ord
            WHERE c.ColName IN (
                SELECT LTRIM(RTRIM(REPLACE(REPLACE(p.value, '[', ''), ']', '')))
                FROM STRING_SPLIT(@pkCols, ',') p
            );

            DECLARE @exists BIT = 0;
            DECLARE @checkSql NVARCHAR(MAX) =
                N'SELECT @out = CASE WHEN EXISTS (SELECT 1 FROM ' + QUOTENAME(@TableName) +
                ' WHERE ' + @whereClause + N') THEN 1 ELSE 0 END';

            EXEC sp_executesql @checkSql, N'@out BIT OUTPUT', @out=@exists OUTPUT;

            IF @exists = 1
            BEGIN
                SET @duplicateCount += 1;
                FETCH NEXT FROM line_cursor INTO @line;
                CONTINUE;
            END
        END

        -- Construire l'INSERT
        DECLARE @sql NVARCHAR(MAX) = N'INSERT INTO ' + QUOTENAME(@TableName) +
            ' (' + @Columns + ') ';

        IF @HasIdentity = 1 AND @IdentityCol IS NOT NULL
            SET @sql += N'OUTPUT INSERTED.' + QUOTENAME(@IdentityCol) + ' AS NewID ';
        SET @sql += N'SELECT ' + @Values;

        BEGIN TRY
            IF @HasIdentity = 1
            BEGIN
                DECLARE @tmp TABLE (NewID INT);
                INSERT INTO @tmp EXEC sp_executesql @sql;

                DECLARE @nid INT = (SELECT TOP 1 NewID FROM @tmp);
                INSERT INTO @output (OldID, NewID)
                SELECT (SELECT Val FROM @valList WHERE Ord = 1), @nid;
            END
            ELSE
                EXEC sp_executesql @sql;
        END TRY
        BEGIN CATCH
            PRINT ERROR_MESSAGE();
        END CATCH

        FETCH NEXT FROM line_cursor INTO @line;
    END

    CLOSE line_cursor;
    DEALLOCATE line_cursor;

    -- Retourner résultats
    SELECT * FROM @output;
    PRINT CAST(@duplicateCount AS NVARCHAR) + ' doublons ignorés.';
END
GO