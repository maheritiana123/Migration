foreach (var fk in fkInfos)
{
    if (!row.ContainsKey(fk.ColumnName)) continue;

    // 1) FK marquée "différée" -> on force NULL à l'insert
    if (nullFkColumns != null && nullFkColumns.Contains(fk.ColumnName))
    {
        row[fk.ColumnName] = null;
        continue;
    }

    // 2) forceNullFK global (rare)
    if (forceNullFK)
    {
        row[fk.ColumnName] = null;
        continue;
    }

    // 3) mapping normal
    var oldFk = (row[fk.ColumnName] ?? "").ToString();
    if (string.IsNullOrWhiteSpace(oldFk)) { row[fk.ColumnName] = null; continue; }

    if (_idMappings.TryGetValue(fk.ReferencedTableName, out var map) && map.TryGetValue(oldFk, out var newFk))
        row[fk.ColumnName] = newFk;
    else if (IsForeignKeyNullable(fk))
        row[fk.ColumnName] = null;
    else
        throw new Exception($"Mapping manquant pour FK {fk.ColumnName} → {fk.ReferencedTableName} (table {tableName})");
}


private void FixupDeferredForeignKeys(string tableName, HashSet<string> columns)
{
    if (columns == null || columns.Count == 0) return;

    Console.WriteLine($"[FIXUP] {tableName} : mise à jour FK différées ({string.Join(",", columns)})");

    string csvPath = Path.Combine(_importPath, $"Export_Migration_{tableName}_{Environment.GetEnvironmentVariable("PFTLSITE")}.csv");
    if (!File.Exists(csvPath)) { Console.WriteLine($"[FIXUP] CSV introuvable {tableName}"); return; }

    var lines = File.ReadAllLines(csvPath, Encoding.UTF8);
    if (lines.Length < 2) return;

    var cols = lines[0].Split(';').Select(s => s.Trim()).ToList();
    var idCol = GetIdentityColumn(tableName);
    if (string.IsNullOrEmpty(idCol))
    {
        Console.WriteLine($"[FIXUP] {tableName} sans IDENTITY : skip (utiliser clé business si besoin).");
        return;
    }

    // pour chaque ligne CSV : retrouver le newId et construire SET col = mappedId
    for (int i = 1; i < lines.Length; i++)
    {
        var vals = lines[i].Split(';');
        if (vals.Length != cols.Count) continue;

        var row = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
        for (int c = 0; c < cols.Count; c++) row[cols[c]] = vals[c];

        var oldId = row.ContainsKey(idCol) ? row[idCol] : null;
        if (string.IsNullOrEmpty(oldId)) continue;

        if (!_idMappings.TryGetValue(tableName, out var tableMap) || !tableMap.TryGetValue(oldId, out var newId))
            continue; // ligne non insérée (doublon/erreur)

        // Build SET ...
        var setParts = new List<string>();
        foreach (var col in columns)
        {
            if (!row.TryGetValue(col, out var oldFkVal) || string.IsNullOrWhiteSpace(oldFkVal))
            {
                setParts.Add($"[{col}]=NULL");
                continue;
            }
            // retrouver la table référencée
            var fk = GetForeignKeyInfo(tableName).FirstOrDefault(f => f.ColumnName.Equals(col, StringComparison.OrdinalIgnoreCase));
            if (fk == null) { setParts.Add($"[{col}]=NULL"); continue; }

            if (_idMappings.TryGetValue(fk.ReferencedTableName, out var map) && map.TryGetValue(oldFkVal, out var mapped))
                setParts.Add($"[{col}]={mapped}");
            else
                setParts.Add($"[{col}]=NULL"); // faute de mieux (sinon lever une erreur)
        }
        if (setParts.Count == 0) continue;

        string sqlTxt = $"UPDATE [{tableName}] SET {string.Join(",", setParts)} WHERE [{idCol}]={newId};";
        var sql = new DynamicSql { Dsn = "PXE1_PXE" };
        sql.AddDirectRequest(sqlTxt, MidwSqlXmlMode.MIDW_SQL_XMLMODE_RAW);
        sql.SetSite(Environment.GetEnvironmentVariable("PFTLSITE"));
        sql.Execute(30000);
    }
}