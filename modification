// Séparateurs pour la PS (doivent matcher la proc SQL)
private const char RS = (char)0x1E; // row separator
private const char CS = (char)0x1D; // column separator

// ------- Import principal : tables "normales" (pas relation "pure") -------
private void ImportTableCommon(string tableName, bool forceNullFK = false, int batchSize = 100)
{
    Console.WriteLine("_______________________");
    Console.WriteLine($"[IMPORT] {tableName}");

    string csvPath = Path.Combine(_importPath, $"Export_Migration_{tableName}_{Environment.GetEnvironmentVariable("PFTLSITE")}.csv");
    if (!File.Exists(csvPath))
    {
        Console.WriteLine($"? CSV introuvable : {tableName}");
        return;
    }

    var lines = File.ReadAllLines(csvPath, Encoding.UTF8);
    if (lines.Length < 2)
    {
        Console.WriteLine($"? CSV vide : {tableName}");
        return;
    }

    // 1) Entêtes CSV
    var columnNames = lines[0].Split(';').Select(c => c.Trim()).ToList();

    // 2) Métadonnées
    var fkInfos = GetForeignKeyInfo(tableName);
    string identityColumn = GetIdentityColumn(tableName); // peut être null
    bool hasIdentity = !string.IsNullOrEmpty(identityColumn);

    // Types (pour formattage)
    var columnTypes = columnNames.ToDictionary(col => col, col => GetColumnType(tableName, col), StringComparer.OrdinalIgnoreCase);

    // 3) Préparer les lignes (mapping FK + exclure IDENTITY)
    var prepared = new List<Dictionary<string, object>>(capacity: lines.Length - 1);
    var oldIdPerRow = new List<string>(); // pour construire le mapping (si Identity)
    int structureSkipped = 0;

    for (int i = 1; i < lines.Length; i++)
    {
        var tokens = lines[i].Split(';');

        // Structure protection (colonnes != valeurs)
        if (tokens.Length != columnNames.Count)
        {
            structureSkipped++;
            continue;
        }

        var row = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
        for (int c = 0; c < columnNames.Count; c++)
        {
            row[columnNames[c]] = tokens[c];
        }

        // garder l'ancien ID (pour mapping) puis retirer de l'insert
        string oldId = null;
        if (hasIdentity && row.ContainsKey(identityColumn))
        {
            oldId = (row[identityColumn] ?? "").ToString();
            row.Remove(identityColumn);
        }
        oldIdPerRow.Add(oldId);

        // FK mapping
        foreach (var fk in fkInfos)
        {
            if (!row.ContainsKey(fk.ColumnName)) continue;

            if (forceNullFK)
            {
                row[fk.ColumnName] = null;
                continue;
            }

            var oldFkValStr = (row[fk.ColumnName] ?? "").ToString();
            if (string.IsNullOrWhiteSpace(oldFkValStr))
            {
                row[fk.ColumnName] = null;
                continue;
            }

            if (_idMappings.TryGetValue(fk.ReferencedTableName, out var map) &&
                map.TryGetValue(oldFkValStr, out var newFkVal))
            {
                row[fk.ColumnName] = newFkVal;
            }
            else
            {
                if (IsForeignKeyNullable(fk))
                    row[fk.ColumnName] = null;
                else
                    throw new Exception($"Mapping manquant pour FK {fk.ColumnName} → {fk.ReferencedTableName} (table {tableName})");
            }
        }

        prepared.Add(row);
    }

    if (prepared.Count == 0)
    {
        Console.WriteLine($"? Table {tableName} : 0 ligne exploitable (structure).");
        return;
    }

    // Ordre des colonnes à insérer = entêtes moins la colonne identity (si présente)
    var insertCols = columnNames.Where(c => !hasIdentity || !c.Equals(identityColumn, StringComparison.OrdinalIgnoreCase)).ToList();
    string columnsSql = string.Join(",", insertCols.Select(c => $"[{c}]"));

    // 4) Batch & appel PS
    int inserted = 0;
    int duplicates = 0;
    int errors = 0;

    int total = prepared.Count;
    Console.WriteLine($"{total} lignes à importer (batch={batchSize})...");

    for (int start = 0; start < total; start += batchSize)
    {
        int count = Math.Min(batchSize, total - start);
        var batchRows = prepared.GetRange(start, count);
        var oldIdsBatch = oldIdPerRow.GetRange(start, count);

        // construit ValuesBatch
        string valuesBatch = BuildValuesBatch(batchRows, insertCols, columnTypes);

        // appel PS
        var sql = new DynamicSql { Dsn = "PXE1_PXE" };
        string request = @"
EXEC dbo.batch_safe_insert_with_type_conversion
    @TableName   = $t$,
    @Columns     = $cols$,
    @ValuesBatch = $vb$,
    @HasIdentity = $hid$,
    @IdentityCol = $idcol$;";
        sql.AddDirectRequest(request, MidwSqlXmlMode.MIDW_SQL_XMLMODE_RAW);
        sql.SetSecureParam("t", tableName, true, 0);
        sql.SetSecureParam("cols", columnsSql, true, 0);
        sql.SetSecureParam("vb", valuesBatch, true, 0);
        sql.SetSecureParam("hid", hasIdentity ? 1 : 0, true, 0);
        sql.SetSecureParam("idcol", hasIdentity ? identityColumn : null, true, 0);
        sql.SetSite(Environment.GetEnvironmentVariable("PFTLSITE"));
        sql.Execute(60000); // 60s batch

        // lecture des résultats (une ligne par row du batch)
        int rows = sql.ReturnedRows(1, 1);
        for (int i = 1; i <= rows; i++)
        {
            // RowIndex 1-based côté PS → recaler sur batch
            int rowIndex = 0;
            int.TryParse(sql.GetValueUsingColName(i, "RowIndex", 1, 1), out rowIndex);
            string newId = sql.GetValueUsingColName(i, "NewID", 1, 1);
            string err = sql.GetValueUsingColName(i, "ErrorMessage", 1, 1);

            if (!string.IsNullOrEmpty(err))
            {
                if (err.IndexOf("Doublon", StringComparison.OrdinalIgnoreCase) >= 0)
                {
                    duplicates++;
                }
                else
                {
                    errors++;
                    Console.WriteLine($"[ERREUR INSERT] {tableName} (batch row {rowIndex}) : {err}");
                }
                continue;
            }

            // succès
            inserted++;

            // mapping oldId->newId si identity
            if (hasIdentity && !string.IsNullOrEmpty(newId) && rowIndex >= 1 && rowIndex <= oldIdsBatch.Count)
            {
                var oldId = oldIdsBatch[rowIndex - 1];
                if (!string.IsNullOrEmpty(oldId))
                {
                    if (!_idMappings.ContainsKey(tableName))
                        _idMappings[tableName] = new Dictionary<object, object>();
                    // évite les overwrites bruyants
                    if (!_idMappings[tableName].ContainsKey(oldId))
                        _idMappings[tableName][oldId] = newId;
                }
            }
        }
    }

    Console.WriteLine($"✓ Table {tableName} : {inserted} insérées, {duplicates} doublons ignorés, {errors} erreurs, {structureSkipped} lignes sautées (structure).");
}


// ------- Helpers -------

// Récupère le nom de la colonne IDENTITY, ou null s'il n'y en a pas
private string GetIdentityColumn(string tableName)
{
    var sql = new DynamicSql { Dsn = "PXE1_PXE" };
    sql.AddDirectRequest(@"
SELECT TOP 1 COLUMN_NAME
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_NAME = $t$
  AND COLUMNPROPERTY(OBJECT_ID(TABLE_NAME), COLUMN_NAME, 'IsIdentity') = 1
", MidwSqlXmlMode.MIDW_SQL_XMLMODE_RAW);
    sql.SetSecureParam("t", tableName, true, 0);
    sql.SetSite(Environment.GetEnvironmentVariable("PFTLSITE"));
    sql.Execute(15000);

    return sql.ReturnedRows(1, 1) > 0 ? sql.GetValueUsingColName(1, "COLUMN_NAME", 1, 1) : null;
}

// Construit la chaîne @ValuesBatch : lignes séparées par RS (0x1E), colonnes par CS (0x1D)
private string BuildValuesBatch(
    List<Dictionary<string, object>> rows,
    List<string> colOrder,
    Dictionary<string, string> columnTypes)
{
    var sb = new StringBuilder(rows.Count * 64);

    for (int i = 0; i < rows.Count; i++)
    {
        if (i > 0) sb.Append(RS);

        var row = rows[i];
        for (int c = 0; c < colOrder.Count; c++)
        {
            if (c > 0) sb.Append(CS);

            var col = colOrder[c];
            var sqlType = columnTypes[col]; // ex: int, nvarchar, date, datetime2, bit, uniqueidentifier, decimal, float...
            row.TryGetValue(col, out var value);
            sb.Append(FormatValueForSqlToken(value, sqlType));
        }
    }

    return sb.ToString();
}

// Formatte UNE valeur en “token SQL” consommable par la PS (pas d’échappement des séparateurs : ils n’apparaissent pas dans les tokens).
private string FormatValueForSqlToken(object value, string sqlType)
{
    if (value == null) return "NULL";
    string s = value.ToString();

    if (string.IsNullOrWhiteSpace(s)) return "NULL";

    string t = (sqlType ?? "").ToLowerInvariant();

    switch (t)
    {
        case "int":
        case "bigint":
        case "smallint":
        case "tinyint":
            // laissons SQL gérer la conversion si besoin (sinon NULL)
            if (long.TryParse(s, NumberStyles.Integer, CultureInfo.InvariantCulture, out var _))
                return s;
            return "NULL";

        case "bit":
            return (s == "1" || s.Equals("true", StringComparison.OrdinalIgnoreCase)) ? "1" : "0";

        case "decimal":
        case "numeric":
        case "money":
        case "smallmoney":
        case "float":
        case "real":
            if (decimal.TryParse(s, NumberStyles.Any, CultureInfo.InvariantCulture, out var _d))
                return _d.ToString(CultureInfo.InvariantCulture);
            return "NULL";

        case "date":
            if (DateTime.TryParse(s, CultureInfo.InvariantCulture, DateTimeStyles.None, out var d0))
                return $"'{d0:yyyy-MM-dd}'";
            return "NULL";

        case "datetime":
        case "datetime2":
        case "smalldatetime":
            if (DateTime.TryParse(s, CultureInfo.InvariantCulture, DateTimeStyles.None, out var d1))
                return $"'{d1:yyyy-MM-dd HH:mm:ss}'";
            return "NULL";

        case "uniqueidentifier":
            if (Guid.TryParse(s, out var g))
                return $"'{g}'";
            return "NULL";

        default:
            // nvarchar / varchar / char / nchar / text...
            return $"'{s.Replace("'", "''")}'";
    }
}

// Vérifie la nullabilité de la FK (déjà chez toi)
private bool IsForeignKeyNullable(ForeignKeyInfo fk)
{
    var sql = new DynamicSql { Dsn = "PXE1_PXE" };
    sql.AddDirectRequest(@"
SELECT is_nullable
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_NAME = $t$ AND COLUMN_NAME = $c$
", MidwSqlXmlMode.MIDW_SQL_XMLMODE_RAW);
    sql.SetSecureParam("t", fk.TableName, true, 0);
    sql.SetSecureParam("c", fk.ColumnName, true, 0);
    sql.SetSite(Environment.GetEnvironmentVariable("PFTLSITE"));
    sql.Execute(10000);

    if (sql.ReturnedRows(1, 1) > 0)
        return string.Equals(sql.GetValueUsingColName(1, "is_nullable", 1, 1), "YES", StringComparison.OrdinalIgnoreCase);

    return false;
}