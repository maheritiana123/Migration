-- 3) construire liste colonnes et valeurs ordonnées
IF @pkCols IS NOT NULL AND LEN(@pkCols) > 0
BEGIN
    DECLARE @colList TABLE (ColName NVARCHAR(128), Ord INT);
    DECLARE @valList TABLE (Val NVARCHAR(MAX), Ord INT);

    -- colonnes
    INSERT INTO @colList (ColName, Ord)
    SELECT LTRIM(RTRIM(REPLACE(REPLACE(value, '[', ''), ']', ''))),
           ROW_NUMBER() OVER (ORDER BY (SELECT NULL))
    FROM STRING_SPLIT(@Columns, ',') c
    WHERE RTRIM(LTRIM(value)) <> '';

    -- valeurs
    IF @ValueTokens IS NOT NULL
    BEGIN
        INSERT INTO @valList (Val, Ord)
        SELECT LTRIM(RTRIM(value)),
               ROW_NUMBER() OVER (ORDER BY (SELECT NULL))
        FROM STRING_SPLIT(@ValueTokens, CHAR(31)) v
        WHERE RTRIM(LTRIM(value)) <> '';
    END
    ELSE
    BEGIN
        INSERT INTO @valList (Val, Ord)
        SELECT LTRIM(RTRIM(value)),
               ROW_NUMBER() OVER (ORDER BY (SELECT NULL))
        FROM STRING_SPLIT(@Values, ',') v
        WHERE RTRIM(LTRIM(value)) <> '';
    END

    ---------------------------------------------------------------------
    -- DEBUG : vérifier nb colonnes vs nb valeurs
    ---------------------------------------------------------------------
    DECLARE @colCount INT = (SELECT COUNT(*) FROM @colList);
    DECLARE @valCount INT = (SELECT COUNT(*) FROM @valList);

    IF @valCount <> @colCount
    BEGIN
        PRINT 'DEBUG: mismatch colonne/valeurs';
        PRINT 'Cols = ' + CAST(@colCount AS NVARCHAR(10)) + ' / Vals = ' + CAST(@valCount AS NVARCHAR(10));
        PRINT 'Columns = ' + @Columns;
        PRINT 'ValueTokens (séparateur |) = ' + REPLACE(ISNULL(@ValueTokens, ''), CHAR(31), '|');
    END
    ---------------------------------------------------------------------

    -- Construire WHERE uniquement pour les colonnes PK/UK trouvées :
    SELECT @whereClause = 
           COALESCE(@whereClause + ' AND ', '') +
           CASE WHEN UPPER(v.Val) = 'NULL' THEN QUOTENAME(c.ColName) + ' IS NULL'
                ELSE QUOTENAME(c.ColName) + ' = ' + v.Val END
    FROM @colList c
    JOIN @valList v ON c.Ord = v.Ord
    WHERE c.ColName IN (
        SELECT LTRIM(RTRIM(REPLACE(REPLACE(p.value, '[', ''), ']', '')) )
        FROM STRING_SPLIT(@pkCols, ',') p
    );
END




// DEBUG : on s'assure qu'on envoie bien autant de tokens que de colonnes
if (tokens.Count != insertColumnsList.Count)
{
    Console.WriteLine($"[DEBUG] {tableName} CSV line #{i+1}: tokens={tokens.Count} vs cols={insertColumnsList.Count}");
}

// DEBUG : aucun token ne contient les séparateurs spéciaux
char RS = (char)30, US = (char)31;
for (int k = 0; k < tokens.Count; k++)
{
    if (tokens[k].IndexOf(RS) >= 0 || tokens[k].IndexOf(US) >= 0)
    {
        Console.WriteLine($"[DEBUG] {tableName} CSV line #{i+1}: token {k} contient un séparateur (caractère 30/31).");
    }
}



string EscapeToken(string t)
{
    if (t == null) return null;
    return t.Replace(((char)31).ToString(), ""); // retire le US
}

...
var safeTokens = tokens.Select(EscapeToken).ToList();
valueTokensPerRow.Add(string.Join(((char)31).ToString(), safeTokens));