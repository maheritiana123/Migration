// utilitaire
private List<string> OrderTablesByDependencies(IEnumerable<string> tables)
{
    // Build graph: child -> parents
    var parents = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);
    var indeg   = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);

    foreach (var t in tables)
    {
        var fks = GetForeignKeyInfo(t);
        var parentSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

        foreach (var fk in fks)
        {
            // ne compte pas les FK différées
            if (_deferredFkColumns.TryGetValue(t, out var set) && set.Contains(fk.ColumnName))
                continue;
            parentSet.Add(fk.ReferencedTableName);
        }

        parents[t] = parentSet;
        indeg[t] = parentSet.Count;
    }

    // Kahn
    var q = new Queue<string>(indeg.Where(kv => kv.Value == 0).Select(kv => kv.Key));
    var order = new List<string>();
    while (q.Count > 0)
    {
        var n = q.Dequeue();
        order.Add(n);
        foreach (var m in tables)
        {
            if (m == n) continue;
            if (parents.TryGetValue(m, out var p) && p.Contains(n))
            {
                indeg[m]--;
                if (indeg[m] == 0) q.Enqueue(m);
            }
        }
    }

    // s’il reste un cycle, on laisse ces tables à la fin (elles seront importées avec FK différées déjà prévues)
    if (order.Count < tables.Count())
        order.AddRange(tables.Where(t => !order.Contains(t)));

    return order;
}


var orderedExtended = OrderTablesByDependencies(_extendedRelations);
foreach (var t in orderedExtended)
{
    ImportTableCommon(t, forceNullFK: false, batchSize: 500, nullFkColumns: _deferredFkColumns.TryGetValue(t, out var s) ? s : null);
}


// en champ de classe
private readonly Dictionary<string, HashSet<string>> _existingIdCache =
    new(StringComparer.OrdinalIgnoreCase);

private bool TryPassThroughExistingId(string table, string value)
{
    if (string.IsNullOrWhiteSpace(value)) return false;

    if (!_existingIdCache.TryGetValue(table, out var set))
    {
        set = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        var idCol = GetIdentityColumn(table); // si null, prends la colonne FK cible si tu la connais
        if (string.IsNullOrEmpty(idCol)) return false; // pas d’identity connu → on ne tente pas

        var sql = new DynamicSql { Dsn = "PXE1_PXE" };
        var req = $"SELECT CAST([{idCol}] AS nvarchar(200)) AS K FROM [{table}] WITH (NOLOCK)";
        sql.AddDirectRequest(req, MidwSqlXmlMode.MIDW_SQL_XMLMODE_RAW);
        sql.SetSite(Environment.GetEnvironmentVariable("PFTLSITE"));
        sql.Execute(60000);
        for (int i = 1; i <= sql.ReturnedRows(1, 1); i++)
            set.Add(sql.GetValueUsingColName(i, "K", 1, 1) ?? "");
        _existingIdCache[table] = set;
    }

    return set.Contains(value);
}


// ... dans la boucle FK, juste avant le throw:
if (_idMappings.TryGetValue(fk.ReferencedTableName, out var map) && map.TryGetValue(oldFk, out var newFk))
{
    row[fk.ColumnName] = newFk;
}
else if (IsForeignKeyNullable(fk))
{
    row[fk.ColumnName] = null;
}
else
{
    // >>> PASS-THROUGH : si la valeur existe déjà chez le parent, on la garde telle quelle
    if (TryPassThroughExistingId(fk.ReferencedTableName, oldFk))
    {
        row[fk.ColumnName] = oldFk; // on conserve la valeur existante
    }
    else
    {
        throw new Exception($"Mapping manquant pour FK {fk.ColumnName} -> {fk.ReferencedTableName} (table {tableName})");
    }
}