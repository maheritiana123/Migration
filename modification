DECLARE @vb NVARCHAR(MAX) = 
       N'''' + N'improbable_12055' + N'''' + NCHAR(29) + N'12055'
    +  NCHAR(30) +
       N'''' + N'vraimentimprobable_23055' + N'''' + NCHAR(29) + N'NULL';

-- (facultatif) Aperçu rapide
SELECT 'PreviewValuesBatch' AS Label,
       REPLACE(REPLACE(@vb, NCHAR(30), N'␞'), NCHAR(29), N'␝') AS Preview;

-- Appel de la procédure
EXEC dbo.batch_safe_insert_with_type_conversion
     @TableName   = N'VarEnv',
     @Columns     = N'[VENom],[ADVAR]',
     @ValuesBatch = @vb,
     @HasIdentity = 1,
     @IdentityCol = N'VEId';


-- Compter les séparateurs dans @vb
SELECT
  TotalLen    = LEN(@vb),
  RowsSep     = (LEN(@vb) - LEN(REPLACE(@vb, NCHAR(30), N''))),
  ColsSep     = (LEN(@vb) - LEN(REPLACE(@vb, NCHAR(29), N'')));




IF OBJECT_ID(N'dbo.batch_safe_insert_with_type_conversion', N'P') IS NOT NULL
    DROP PROCEDURE dbo.batch_safe_insert_with_type_conversion;
GO
CREATE PROCEDURE dbo.batch_safe_insert_with_type_conversion
    @TableName      NVARCHAR(128),
    @Columns        NVARCHAR(MAX),     -- ex: [Col1],[Col2]
    @ValuesBatch    NVARCHAR(MAX),     -- lignes: NCHAR(30), colonnes: NCHAR(29)
    @HasIdentity    BIT = 0,
    @IdentityCol    NVARCHAR(128) = NULL  -- si NULL et @HasIdentity=1 => auto-détection
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @RS NCHAR(1) = NCHAR(30);  -- séparateur de lignes
    DECLARE @CS NCHAR(1) = NCHAR(29);  -- séparateur de colonnes

    -- Auto-détection de la colonne identity si nécessaire
    IF @HasIdentity = 1 AND (ISNULL(@IdentityCol, N'') = N'')
    BEGIN
        SELECT TOP 1 @IdentityCol = COLUMN_NAME
        FROM INFORMATION_SCHEMA.COLUMNS
        WHERE TABLE_NAME = @TableName
          AND COLUMNPROPERTY(OBJECT_ID(TABLE_NAME), COLUMN_NAME, 'IsIdentity') = 1;
    END

    -- Colonnes PK/UNIQUE hors identity pour la détection de doublons
    DECLARE @pkCols NVARCHAR(MAX);
    SELECT @pkCols = STRING_AGG(QUOTENAME(kcu.COLUMN_NAME), ',')
    FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc
    JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu
      ON tc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
     AND tc.TABLE_NAME = kcu.TABLE_NAME
    WHERE tc.TABLE_NAME = @TableName
      AND tc.CONSTRAINT_TYPE IN ('PRIMARY KEY','UNIQUE')
      AND kcu.COLUMN_NAME <> ISNULL(@IdentityCol, N'');

    -- Normaliser: supprimer CR/LF parasites éventuels
    SET @ValuesBatch = REPLACE(REPLACE(@ValuesBatch, NCHAR(13), N''), NCHAR(10), N'');

    -- Découpage des lignes avec ordinal (préserve l’ordre)
    DECLARE @rows TABLE(RowIndex INT, Line NVARCHAR(MAX));
    INSERT INTO @rows(RowIndex, Line)
    SELECT s.[ordinal], s.[value]
    FROM STRING_SPLIT(@ValuesBatch, @RS, 1) AS s
    WHERE s.[value] IS NOT NULL AND LEN(s.[value]) > 0;

    IF NOT EXISTS (SELECT 1 FROM @rows)
    BEGIN
        SELECT 0 AS RowIndex, NULL AS NewID, N'Batch vide (aucune ligne découpée)' AS ErrorMessage;
        RETURN;
    END

    -- Préparer les colonnes d’INSERT dans l’ordre
    DECLARE @colList TABLE(ColName NVARCHAR(128), Ord INT);
    INSERT INTO @colList(ColName, Ord)
    SELECT LTRIM(RTRIM(REPLACE(REPLACE(value, '[',''),']',''))),
           ROW_NUMBER() OVER (ORDER BY (SELECT 1))
    FROM STRING_SPLIT(@Columns, ',')
    WHERE RTRIM(LTRIM(value)) <> N'';

    DECLARE @out TABLE(RowIndex INT, NewID NVARCHAR(100), ErrorMessage NVARCHAR(MAX));

    DECLARE @i INT = 1, @n INT = (SELECT COUNT(*) FROM @rows);
    WHILE @i <= @n
    BEGIN
        DECLARE @line NVARCHAR(MAX) = (SELECT Line FROM @rows WHERE RowIndex=@i);

        -- Découper les valeurs de la ligne (avec ordinal)
        DECLARE @valList TABLE(Val NVARCHAR(MAX), Ord INT);
        INSERT INTO @valList(Val, Ord)
        SELECT s.[value], s.[ordinal]
        FROM STRING_SPLIT(@line, @CS, 1) AS s;

        -- Construire WHERE pour doublons si pkCols présent
        DECLARE @where NVARCHAR(MAX) = N'';
        IF @pkCols IS NOT NULL AND LEN(@pkCols) > 0
        BEGIN
            DECLARE @conds TABLE(Cond NVARCHAR(MAX), Ord INT);
            INSERT INTO @conds(Cond, Ord)
            SELECT
                CASE WHEN UPPER(v.Val)=N'NULL'
                     THEN QUOTENAME(c.ColName) + N' IS NULL'
                     ELSE QUOTENAME(c.ColName) + N' = ' + v.Val END,
                c.Ord
            FROM @colList c
            JOIN @valList v ON v.Ord = c.Ord
            WHERE c.ColName IN (
                SELECT LTRIM(RTRIM(REPLACE(REPLACE(p.value, '[',''),']','')))
                FROM STRING_SPLIT(@pkCols, ',') p
            );

            SELECT @where = STRING_AGG(Cond, N' AND ') WITHIN GROUP (ORDER BY Ord)
            FROM @conds;

            IF LEN(@where) > 0
            BEGIN
                DECLARE @exists BIT;
                DECLARE @chk NVARCHAR(MAX) = N'SELECT @o = CASE WHEN EXISTS (SELECT 1 FROM '
                                           + QUOTENAME(@TableName) + N' WITH (NOLOCK) WHERE ' + @where + N') THEN 1 ELSE 0 END';
                EXEC sp_executesql @chk, N'@o bit OUTPUT', @o=@exists OUTPUT;
                IF @exists = 1
                BEGIN
                    INSERT INTO @out VALUES(@i, NULL, N'Doublon');
                    SET @i += 1;
                    CONTINUE;
                END
            END
        END

        -- Assembler la liste des valeurs pour l’INSERT (ordre des colonnes)
        DECLARE @values NVARCHAR(MAX);
        SELECT @values = STRING_AGG(Val, N',') WITHIN GROUP (ORDER BY Ord)
        FROM @valList;

        IF ISNULL(@values, N'') = N'' SET @values = N'NULL';

        DECLARE @sql NVARCHAR(MAX) = N'INSERT INTO ' + QUOTENAME(@TableName) + N' (' + @Columns + N') ';
        IF @HasIdentity = 1 AND @IdentityCol IS NOT NULL
            SET @sql += N'OUTPUT INSERTED.' + QUOTENAME(@IdentityCol) + N' AS NewID ';
        SET @sql += N'SELECT ' + @values;

        BEGIN TRY
            IF @HasIdentity = 1 AND @IdentityCol IS NOT NULL
            BEGIN
                DECLARE @tmp TABLE(NewID NVARCHAR(100));
                INSERT INTO @tmp EXEC sp_executesql @sql;
                INSERT INTO @out
                SELECT @i, NewID, NULL FROM @tmp;
            END
            ELSE
            BEGIN
                EXEC sp_executesql @sql;
                INSERT INTO @out VALUES(@i, NULL, NULL);
            END
        END TRY
        BEGIN CATCH
            INSERT INTO @out VALUES(@i, NULL, N'ERR: ' + ERROR_MESSAGE() + N' | vals=' + ISNULL(@values,N''));
        END CATCH

        SET @i += 1;
    END

    SELECT RowIndex, NewID, ErrorMessage
    FROM @out
    ORDER BY RowIndex;
END
GO