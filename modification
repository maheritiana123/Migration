private void ImportTableCommon(string tableName, bool forceNullFK = false)
{
    Console.WriteLine("_______________________");
    Console.WriteLine($"Import table {tableName}");

    string csvPath = Path.Combine(_importPath, $"Export_Migration_{tableName}_{Environment.GetEnvironmentVariable("PFTLSITE")}.csv");
    if (!File.Exists(csvPath))
    {
        Console.WriteLine($"⚠ CSV introuvable : {tableName}");
        return;
    }

    // Lecture unique
    var lines = File.ReadAllLines(csvPath);
    if (lines.Length < 2)
    {
        Console.WriteLine($"⚠ CSV vide : {tableName}");
        return;
    }

    // En-têtes
    var columnNamesAll = lines[0].Split(';').Select(c => c.Trim()).ToList();
    var identityColumn = GetIdentityColumn(tableName); // string? (null si pas d'identity)
    var fkInfos = GetForeignKeyInfo(tableName);
    bool hasIdentity = !string.IsNullOrEmpty(identityColumn);

    // Colonnes réellement insérées (on enlève l’identity si présent)
    var columnNamesInserted = hasIdentity
        ? columnNamesAll.Where(c => !string.Equals(c, identityColumn, StringComparison.OrdinalIgnoreCase)).ToList()
        : new List<string>(columnNamesAll);

    // Chaîne @Columns pour la PS, figée une fois pour toutes
    string columnsForProc = string.Join(",", columnNamesInserted.Select(c => $"[{c}]"));

    Console.WriteLine($"{lines.Length - 1} lignes à importer...");

    // Construit le batch en une passe
    var rowSep = ((char)30).ToString(); // NCHAR(30)
    var colSep = ((char)31).ToString(); // NCHAR(31)
    var batchRows = new List<string>();
    int duplicateCount = 0;
    int insertedCount = 0;

    for (int i = 1; i < lines.Length; i++)
    {
        var values = lines[i].Split(';').ToList();
        if (values.Count != columnNamesAll.Count)
        {
            Console.WriteLine($"[Erreur Structurelle] {tableName} Ligne {i + 1}: colonnes CSV ({values.Count}) != colonnes table ({columnNamesAll.Count}). Ligne ignorée.");
            continue;
        }

        // Dictionnaire de la ligne
        var rowDict = columnNamesAll.Zip(values, (col, val) => new { col, val })
                                    .ToDictionary(x => x.col, x => (object)x.val);

        // Retire l’identity de la ligne si présent (on n’insère jamais la PK auto)
        if (hasIdentity && rowDict.ContainsKey(identityColumn))
            rowDict.Remove(identityColumn);

        // Mapping des FK
        foreach (var fk in fkInfos)
        {
            if (!rowDict.ContainsKey(fk.ColumnName))
                continue;

            if (forceNullFK)
            {
                rowDict[fk.ColumnName] = null;
                continue;
            }

            var oldFkValue = (rowDict[fk.ColumnName] ?? "").ToString();
            if (string.IsNullOrWhiteSpace(oldFkValue))
            {
                rowDict[fk.ColumnName] = null; // valeur vide -> NULL
                continue;
            }

            if (_idMappings.TryGetValue(fk.ReferencedTableName, out var map) &&
                map.TryGetValue(oldFkValue, out var newFkValue))
            {
                rowDict[fk.ColumnName] = newFkValue;
            }
            else if (IsForeignKeyNullable(fk))
            {
                rowDict[fk.ColumnName] = null; // FK nullable -> on met NULL
            }
            else
            {
                throw new Exception($"Mapping manquant pour FK {fk.ColumnName} → {fk.ReferencedTableName} (table {tableName})");
            }
        }

        // Formate chaque valeur selon son type SQL, dans l’ordre de columnNamesInserted
        var tokens = new List<string>(capacity: columnNamesInserted.Count);
        foreach (var col in columnNamesInserted)
        {
            var sqlType = GetColumnType(tableName, col);
            rowDict.TryGetValue(col, out var val);
            tokens.Add(FormatValueForSql(val, sqlType));
        }

        // Ajoute la ligne formatée (séparateur colonnes = CHAR(31))
        batchRows.Add(string.Join(colSep, tokens));
    }

    if (batchRows.Count == 0)
    {
        Console.WriteLine("Aucune ligne exploitable dans ce CSV.");
        return;
    }

    // Concatène toutes les lignes (séparateur lignes = CHAR(30))
    string valuesBatch = string.Join(rowSep, batchRows);

    // Exécute la PS une seule fois
    var sql = new DynamicSql { Dsn = "PXE1_PXE" };
    string request = @"EXEC [dbo].[batch_safe_insert_with_type_conversion] 
        @TableName = $table$, 
        @Columns = $cols$, 
        @ValuesBatch = $valsBatch$,
        @HasIdentity = $identity$,
        @IdentityCol = $idCol$";

    sql.AddDirectRequest(request, MidwSqlXmlMode.MIDW_SQL_XMLMODE_RAW);
    sql.SetSecureParam("table", tableName, true, 0);
    sql.SetSecureParam("cols", columnsForProc, true, 0);
    sql.SetSecureParam("valsBatch", valuesBatch, true, 0);
    sql.SetSecureParam("identity", hasIdentity ? 1 : 0, true, 0);
    sql.SetSecureParam("idCol", identityColumn ?? "", true, 0);
    sql.SetSite(Environment.GetEnvironmentVariable("PFTLSITE"));

    sql.Execute(300000); // augmente le timeout si nécessaire

    // Parcours du résultat renvoyé par la PS (une ligne par ligne traitée)
    int rows = sql.ReturnedRows(1, 1);
    for (int r = 1; r <= rows; r++)
    {
        string err = sql.GetValueUsingColName(r, "ErrorMessage", 1, 1);
        if (!string.IsNullOrEmpty(err) && err.IndexOf("Doublon", StringComparison.OrdinalIgnoreCase) >= 0)
            duplicateCount++;
        else if (string.IsNullOrEmpty(err))
            insertedCount++;
        // sinon : c’est une erreur bloquante, tu peux logger err ici si tu veux
    }

    Console.WriteLine($"✅ Table {tableName} : {insertedCount} lignes insérées, {duplicateCount} doublons ignorés.");
}