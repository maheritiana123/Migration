@TableName   = N'VarEnv',
@Columns     = N'[VENom],[ADVAR]',
@ValuesBatch = N'''WPNumStat''||NULL$$''WPED''||NULL',
@HasIdentity = 1,
@IdentityCol = N'VEId'


-- Debug: afficher longueur et début du batch après normalisation
DECLARE @VB NVARCHAR(MAX) = ISNULL(@ValuesBatch, N'');

-- Si tu as déjà mis la normalisation, garde la même variable (@VB)
SET @VB = REPLACE(@VB, N'§§', NCHAR(30));
SET @VB = REPLACE(@VB, N'$$', NCHAR(30));
SET @VB = REPLACE(@VB, N'||', NCHAR(31));

RAISERROR(N'VB len=%d head=%s', 10, 1, LEN(@VB), LEFT(REPLACE(@VB, NCHAR(31), N'|'), 200)) WITH NOWAIT;


DECLARE @rowsCount INT = (SELECT COUNT(*) FROM @rows);
RAISERROR(N'rows=%d', 10, 1, @rowsCount) WITH NOWAIT;

-- (temporaire) voir la première ligne de tokens
IF @rowsCount > 0
BEGIN
    DECLARE @first NVARCHAR(MAX) = (SELECT TOP(1) Tokens FROM @rows ORDER BY RowIndex);
    RAISERROR(N'first tokens=%s', 10, 1, LEFT(REPLACE(@first, NCHAR(31), N'|'), 200)) WITH NOWAIT;
END


IF NOT EXISTS (SELECT 1 FROM @rows)
BEGIN
    -- on pousse le batch complet comme UNE ligne pour avoir au moins un retour
    INSERT INTO @rows (Tokens) VALUES (@VB);
    RAISERROR(N'rows empty → pushed 1', 10, 1) WITH NOWAIT;
END


const string COL_SEP = "||";
const string ROW_SEP = "$$";

// tokens = FormatValueForSql(value, type)  → '...' ou NULL (sans quotes)
valueTokensPerRow.Add(string.Join(COL_SEP, tokens));

string valuesBatch = string.Join(ROW_SEP, valueTokensPerRow);
sql.SetSecureParam("ValuesBatch", valuesBatch, true, 0);

Console.WriteLine($"[DEBUG] columnsSql = {columnsSql}  (count={insertColumnsList.Count})");
Console.WriteLine($"[DEBUG] first row tokens = {valueTokensPerRow.FirstOrDefault()}");