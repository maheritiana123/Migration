private void ImportTableCommon(string tableName, bool forceNullFK = false)
{
    Console.WriteLine("_______________________");
    Console.WriteLine($"Import table {tableName}");

    string csvPath = Path.Combine(
        _importPath,
        $"Export_Migration_{tableName}_{Environment.GetEnvironmentVariable("PFTLSITE")}.csv"
    );

    if (!File.Exists(csvPath))
    {
        Console.WriteLine($"‚ö† CSV introuvable : {tableName}");
        return;
    }

    var lines = File.ReadAllLines(csvPath);
    if (lines.Length < 2)
    {
        Console.WriteLine($"‚ö† CSV vide : {tableName}");
        return;
    }

    // Lecture en-t√™te CSV
    var columnNames = lines[0].Split(';').Select(c => c.Trim()).ToList();

    // Info PK, FK, Identity
    var identityColumn = GetIdentityColumn(tableName);
    var fkInfos = GetForeignKeyInfo(tableName);

    bool hasIdentity = !string.IsNullOrEmpty(identityColumn);
    Console.WriteLine($"{lines.Length - 1} lignes √† importer");

    for (int i = 1; i < lines.Length; i++)
    {
        var values = lines[i].Split(';').ToList();

        // Mapping colonnes/valeurs
        var rowDict = columnNames.Zip(values, (col, val) => new { col, val })
                                 .ToDictionary(x => x.col, x => x.val);

        // Stocker l'ancien ID si table √† IDENTITY
        string oldId = null;
        if (hasIdentity && rowDict.ContainsKey(identityColumn))
        {
            oldId = rowDict[identityColumn];
            rowDict.Remove(identityColumn); // ‚ùå On ne r√©ins√®re pas l'IDENTITY
        }

        // üîπ Remplacement des FK par les nouveaux IDs
        foreach (var fk in fkInfos)
        {
            if (forceNullFK)
            {
                rowDict[fk.ColumnName] = "NULL";
                continue;
            }

            var oldFkValue = rowDict[fk.ColumnName];
            if (string.IsNullOrWhiteSpace(oldFkValue))
                continue;

            if (_idMappings.TryGetValue(fk.ReferencedTableName, out var map) &&
                map.TryGetValue(oldFkValue, out var newFkValue))
            {
                rowDict[fk.ColumnName] = newFkValue;
            }
            else if (fk.IsNullable)
            {
                rowDict[fk.ColumnName] = "NULL";
            }
            else
            {
                throw new Exception($"Mapping manquant pour FK {fk.ColumnName} ‚Üí {fk.ReferencedTableName}");
            }
        }

        // üîπ Colonnes format√©es
        var insertColumns = string.Join(", ", rowDict.Keys.Select(c => $"[{c}]"));

        // üîπ Valeurs format√©es en fonction du type SQL
        var insertValues = string.Join(", ",
            rowDict.Select(kv => FormatValueForSql(kv.Value, GetColumnType(tableName, kv.Key)))
        );

        // DEBUG (optionnel)
        // Console.WriteLine($"[DEBUG] {tableName} -> {insertColumns} VALUES {insertValues}");

        // üîπ Appel √† la proc√©dure stock√©e
        DynamicSql sql = new DynamicSql { Dsn = "PXE1_PXE" };

        string request = @"EXEC [dbo].[batch_safe_insert_with_type_conversion] 
              @TableName = $table$, 
              @Columns = $cols$, 
              @Values = $vals$,
              @HasIdentity = $identity$";

        sql.AddDirectRequest(request, MidwSqlXmlMode.MIDW_SQL_XMLMODE_RAW);
        sql.SetSecureParam("table", tableName, true, 0);
        sql.SetSecureParam("cols", insertColumns, true, 0);
        sql.SetSecureParam("vals", insertValues, true, 0);
        sql.SetSecureParam("identity", hasIdentity ? 1 : 0, true, 0);

        sql.Execute();

        // üîπ Gestion du retour
        string newId = sql.GetValueUsingColName(1, "NewID", 1, 1);
        string errMsg = sql.GetValueUsingColName(1, "ErrorMessage", 1, 1);

        if (!string.IsNullOrEmpty(errMsg))
        {
            Console.WriteLine($"‚ö† Erreur insertion {tableName} (ancienne ID: {oldId ?? "-"}) ‚Üí {errMsg}");
        }

        if (hasIdentity && !string.IsNullOrEmpty(newId) && !string.IsNullOrEmpty(oldId))
        {
            if (!_idMappings.ContainsKey(tableName))
                _idMappings[tableName] = new Dictionary<string, string>();

            _idMappings[tableName][oldId] = newId;
        }
    }
}
private string FormatValueForSql(string value, string sqlType)
{
    if (string.IsNullOrEmpty(value) || value.Equals("NULL", StringComparison.OrdinalIgnoreCase))
        return "NULL";

    switch (sqlType.ToLower())
    {
        case "int":
        case "bigint":
        case "smallint":
        case "tinyint":
        case "decimal":
        case "numeric":
        case "float":
        case "real":
            return value.Replace(",", "."); // d√©cimal invariant

        case "bit":
            return (value == "1" || value.ToLower() == "true") ? "1" : "0";

        case "datetime":
        case "smalldatetime":
        case "date":
        case "time":
            if (DateTime.TryParse(value, out var dt))
                return $"'{dt:yyyy-MM-dd HH:mm:ss}'";
            return "NULL";

        default:
            // Cha√Æne ‚Üí √©chapper les quotes simples
            return $"'{value.Replace("'", "''")}'";
    }
}
private string GetColumnType(string tableName, string columnName)
{
    // Requ√™te pour interroger INFORMATION_SCHEMA
    DynamicSql sql = new DynamicSql { Dsn = "PXE1_PXE" };
    string request = @"SELECT DATA_TYPE 
                       FROM INFORMATION_SCHEMA.COLUMNS 
                       WHERE TABLE_NAME = $table$ 
                         AND COLUMN_NAME = $col$";
    sql.AddDirectRequest(request, MidwSqlXmlMode.MIDW_SQL_XMLMODE_RAW);
    sql.SetSecureParam("table", tableName, true, 0);
    sql.SetSecureParam("col", columnName, true, 0);
    sql.Execute();

    return sql.GetValueUsingColName(1, "DATA_TYPE", 1, 1);
}
IF OBJECT_ID(N'[dbo].[batch_safe_insert_with_type_conversion]', N'P') IS NOT NULL
    DROP PROCEDURE [dbo].[batch_safe_insert_with_type_conversion];
GO

CREATE PROCEDURE [dbo].[batch_safe_insert_with_type_conversion]
    @TableName NVARCHAR(128),    -- Nom de la table
    @Columns NVARCHAR(MAX),      -- Liste des colonnes d√©j√† format√©e : [Col1],[Col2],...
    @Values NVARCHAR(MAX),       -- Liste des valeurs d√©j√† format√©e : 'val1',NULL,123,...
    @HasIdentity BIT = 0         -- 1 si table avec colonne IDENTITY
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @sql NVARCHAR(MAX);
    DECLARE @identityCol NVARCHAR(128);
    DECLARE @output TABLE (NewID INT);

    -- Si IDENTITY demand√©, chercher la colonne
    IF @HasIdentity = 1
    BEGIN
        SELECT TOP 1 @identityCol = COLUMN_NAME
        FROM INFORMATION_SCHEMA.COLUMNS
        WHERE TABLE_NAME = @TableName
          AND COLUMNPROPERTY(OBJECT_ID(TABLE_NAME), COLUMN_NAME, 'IsIdentity') = 1;

        IF @identityCol IS NULL
        BEGIN
            SELECT NULL AS NewID, 'Aucune colonne IDENTITY trouv√©e pour cette table' AS ErrorMessage;
            RETURN;
        END
    END

    -- Construire la requ√™te d'INSERT
    SET @sql = N'INSERT INTO ' + QUOTENAME(@TableName) + ' (' + @Columns + ') ';

    -- Ajout de l'OUTPUT si IDENTITY
    IF @HasIdentity = 1
        SET @sql += N'OUTPUT INSERTED.' + QUOTENAME(@identityCol) + ' AS NewID ';

    SET @sql += N'SELECT ' + @Values;

    BEGIN TRY
        IF @HasIdentity = 1
            INSERT INTO @output EXEC sp_executesql @sql;
        ELSE
            EXEC sp_executesql @sql;

        -- Retourner l'ID g√©n√©r√© si pr√©sent
        IF @HasIdentity = 1
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM @output)
            BEGIN
                SELECT NULL AS NewID, 'INSERT effectu√© mais aucun IDENTITY retourn√©' AS ErrorMessage;
                RETURN;
            END

            SELECT NewID, NULL AS ErrorMessage FROM @output;
            RETURN;
        END
        ELSE
        BEGIN
            SELECT NULL AS NewID, NULL AS ErrorMessage; -- Pas d'IDENTITY
            RETURN;
        END
    END TRY
    BEGIN CATCH
        SELECT NULL AS NewID, ERROR_MESSAGE() AS ErrorMessage;
    END CATCH
END
GO
