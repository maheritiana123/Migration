/* =========[ 1) Charger le CSV brut (1 seule colonne) ]========= */
IF OBJECT_ID('tempdb..#raw') IS NOT NULL DROP TABLE #raw;
CREATE TABLE #raw (rn INT IDENTITY(1,1), line NVARCHAR(MAX));

-- ⚠️ Chemin à adapter (serveur SQL doit voir ce chemin)
BULK INSERT #raw
FROM 'C:\temp\networkprinters.csv'
WITH (
    CODEPAGE = '65001',           -- UTF-8 (adapte si besoin)
    FIELDTERMINATOR = '\n',       -- on avale la ligne entière
    ROWTERMINATOR   = '\n',       -- fin de ligne
    FIRSTROW = 1                  -- garder l'entête : on va s'en servir
);

/* =========[ 2) Récupérer l'entête et l'index de la colonne net_position ]========= */
DECLARE @header NVARCHAR(MAX) =
    (SELECT TOP(1) line FROM #raw ORDER BY rn);

-- éclater l'entête sur ';' AVEC ORDRE (via XML) pour trouver l'index de net_position
DECLARE @netPosIdx INT;

;WITH HeaderParts AS (
    SELECT ROW_NUMBER() OVER (ORDER BY (SELECT 1)) AS idx,
           T.C.value('.','nvarchar(4000)') AS col
    FROM (SELECT CAST('<r><c>' + REPLACE(@header,';','</c><c>') + '</c></r>' AS XML) AS X) H
    CROSS APPLY H.X.nodes('/r/c') AS T(C)
)
SELECT @netPosIdx = idx
FROM HeaderParts
WHERE LTRIM(RTRIM(col)) = 'net_position';

IF @netPosIdx IS NULL
BEGIN
    RAISERROR('Colonne net_position introuvable dans l''entête CSV.', 16, 1);
    RETURN;
END

/* =========[ 3) Extraire net_position pour chaque ligne de données ]========= */
IF OBJECT_ID('tempdb..#np_csv') IS NOT NULL DROP TABLE #np_csv;
CREATE TABLE #np_csv (net_position NVARCHAR(4000) NULL);

;WITH RowsOnly AS (
    SELECT rn, line FROM #raw WHERE rn >= 2 AND NULLIF(LTRIM(RTRIM(line)),N'') IS NOT NULL
),
Parts AS (
    -- on split chaque ligne en cellules numérotées
    SELECT R.rn,
           ROW_NUMBER() OVER (PARTITION BY R.rn ORDER BY (SELECT 1)) AS idx,
           P.C.value('.','nvarchar(max)') AS val
    FROM RowsOnly R
    CROSS APPLY (SELECT CAST('<r><c>' + REPLACE(R.line,';','</c><c>') + '</c></r>' AS XML) AS X) X
    CROSS APPLY X.X.nodes('/r/c') AS P(C)
)
INSERT INTO #np_csv(net_position)
SELECT NULLIF(LTRIM(RTRIM(val)),N'')
FROM Parts
WHERE idx = @netPosIdx;

/* =========[ 4) Rapports utiles ]========= */

PRINT '--- Doublons déjà existants en base (epk) ---';
SELECT c.net_position, COUNT(*) AS OccurencesCSV
FROM #np_csv AS c
JOIN dbo.epk AS e
  ON e.net_position = c.net_position
GROUP BY c.net_position
ORDER BY c.net_position;

PRINT '--- Doublons à l''intérieur du CSV ---';
SELECT net_position, COUNT(*) AS Nb
FROM #np_csv
GROUP BY net_position
HAVING COUNT(*) > 1
ORDER BY Nb DESC, net_position;

PRINT '--- Valeurs du CSV qui passeraient sans conflit dans epk ---';
SELECT c.net_position
FROM #np_csv AS c
LEFT JOIN dbo.epk AS e
  ON e.net_position = c.net_position
WHERE e.net_position IS NULL
ORDER BY c.net_position;

PRINT '--- Synthèse ---';
SELECT
    (SELECT COUNT(*) FROM #np_csv)                                         AS TotalCSV,
    (SELECT COUNT(*) FROM #np_csv WHERE net_position IS NULL)              AS CSV_Nulls,
    (SELECT COUNT(*) FROM #np_csv GROUP BY net_position HAVING COUNT(*)>1) AS CSV_DuplKeys,
    (SELECT COUNT(*) FROM #np_csv AS c JOIN dbo.epk AS e
        ON e.net_position=c.net_position)                                  AS ConflitsAvecEPK;