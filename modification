private void ImportPureRelationsUntilStable(List<string> pureRelations)
{
    if (pureRelations == null || pureRelations.Count == 0) return;

    bool progress;
    int pass = 0;
    do
    {
        progress = false;
        pass++;
        Console.WriteLine($"[PURE] Pass {pass}");

        foreach (var table in pureRelations)
        {
            int before = _lastInsertedCount;
            ImportPureRelation(table);
            progress |= (_lastInsertedCount > before);
        }
    } while (progress && pass < 5); // borne de sécurité
}

// Petit compteur partagé (à mettre au niveau classe)
private int _lastInsertedCount = 0;

private void ImportPureRelation(string tableName)
{
    string csvPath = Path.Combine(_importPath, $"Export_Migration_{tableName}_{Environment.GetEnvironmentVariable("PFTLSITE")}.csv");
    if (!File.Exists(csvPath)) return;

    var lines = File.ReadAllLines(csvPath, Encoding.UTF8);
    if (lines.Length < 2) return;

    var columnNames = lines[0].Split(';').Select(s => s.Trim()).ToList();
    var fkInfos = GetForeignKeyInfo(tableName);
    var columnTypes = columnNames.ToDictionary(c => c, c => GetColumnType(tableName, c), StringComparer.OrdinalIgnoreCase);

    // On prépare uniquement les lignes pour lesquelles TOUTES les FK ont un mapping
    var batchRows = new List<Dictionary<string, object>>();
    for (int i = 1; i < lines.Length; i++)
    {
        var vals = lines[i].Split(';');
        if (vals.Length != columnNames.Count) continue;

        var row = new Dictionary<string, object>(StringComparer.OrdinalIgnoreCase);
        for (int c = 0; c < columnNames.Count; c++) row[columnNames[c]] = vals[c];

        bool ok = true;
        foreach (var fk in fkInfos)
        {
            var oldVal = (row[fk.ColumnName] ?? "").ToString();
            if (string.IsNullOrWhiteSpace(oldVal)) { row[fk.ColumnName] = null; continue; }

            if (_idMappings.TryGetValue(fk.ReferencedTableName, out var map) && map.TryGetValue(oldVal, out var newVal))
                row[fk.ColumnName] = newVal;
            else
            {
                ok = false; break; // on attend un prochain pass
            }
        }
        if (ok) batchRows.Add(row);
    }

    if (batchRows.Count == 0) { _lastInsertedCount = 0; return; }

    string columnsSql = string.Join(",", columnNames.Select(c => $"[{c}]"));
    string valuesBatch = BuildValuesBatch(batchRows, columnNames, columnTypes); // réutilise le helper
    var sql = new DynamicSql { Dsn = "PXE1_PXE" };
    string req = @"
EXEC dbo.batch_safe_insert_with_type_conversion
  @TableName=$t$, @Columns=$cols$, @ValuesBatch=$vb$, @HasIdentity=0, @IdentityCol=NULL;";
    sql.AddDirectRequest(req, MidwSqlXmlMode.MIDW_SQL_XMLMODE_RAW);
    sql.SetSecureParam("t", tableName, true, 0);
    sql.SetSecureParam("cols", columnsSql, true, 0);
    sql.SetSecureParam("vb", valuesBatch, true, 0);
    sql.SetSite(Environment.GetEnvironmentVariable("PFTLSITE"));
    sql.Execute(60000);

    int inserted = 0;
    int rows = sql.ReturnedRows(1, 1);
    for (int r = 1; r <= rows; r++)
    {
        string err = sql.GetValueUsingColName(r, "ErrorMessage", 1, 1);
        if (string.IsNullOrEmpty(err)) inserted++;
        else if (err.IndexOf("Doublon", StringComparison.OrdinalIgnoreCase) >= 0) { /* ignore */ }
        else Console.WriteLine($"[PURE ERR] {tableName}: {err}");
    }
    _lastInsertedCount = inserted;
    Console.WriteLine($"[PURE] {tableName}: {inserted} lignes insérées (pass).");
}