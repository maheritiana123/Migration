IF OBJECT_ID(N'[dbo].[batch_safe_insert_with_type_conversion]', N'P') IS NOT NULL
    DROP PROCEDURE [dbo].[batch_safe_insert_with_type_conversion];
GO

CREATE PROCEDURE [dbo].[batch_safe_insert_with_type_conversion]
    @TableName      NVARCHAR(128),
    @Columns        NVARCHAR(MAX),      -- ex: [Col1],[Col2]
    @ValuesBatch    NVARCHAR(MAX),      -- lignes séparées par NCHAR(30) ; valeurs séparées par NCHAR(29)
    @HasIdentity    BIT          = 0,
    @IdentityCol    NVARCHAR(128)= NULL -- peut rester NULL : auto-détection si @HasIdentity=1
AS
BEGIN
    SET NOCOUNT ON;
    SET LOCK_TIMEOUT 5000;
    SET DEADLOCK_PRIORITY LOW;

    -------------------------------------------------------------------------
    -- Séparateurs : RS = row separator (0x1E), CS = column separator (0x1D)
    -------------------------------------------------------------------------
    DECLARE @RS nchar(1) = NCHAR(30);
    DECLARE @CS nchar(1) = NCHAR(29);

    -------------------------------------------------------------------------
    -- Détection de la colonne IDENTITY si nécessaire
    -------------------------------------------------------------------------
    IF @HasIdentity = 1 AND ( @IdentityCol IS NULL OR LEN(@IdentityCol)=0 )
    BEGIN
        SELECT TOP (1) @IdentityCol = c.COLUMN_NAME
        FROM INFORMATION_SCHEMA.COLUMNS c
        WHERE c.TABLE_NAME = @TableName
          AND COLUMNPROPERTY(OBJECT_ID(c.TABLE_NAME), c.COLUMN_NAME, 'IsIdentity') = 1;
    END

    -------------------------------------------------------------------------
    -- Colonnes PK/UK (hors éventuelle colonne identity)
    -- (agrégation avec FOR XML PATH pour SQL 2016)
    -------------------------------------------------------------------------
    DECLARE @pkCols NVARCHAR(MAX);

    ;WITH PKU AS (
        SELECT kcu.COLUMN_NAME
        FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc
        JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE kcu
          ON tc.CONSTRAINT_NAME = kcu.CONSTRAINT_NAME
         AND tc.TABLE_NAME      = kcu.TABLE_NAME
        WHERE tc.TABLE_NAME = @TableName
          AND tc.CONSTRAINT_TYPE IN ('PRIMARY KEY','UNIQUE')
          AND ( @IdentityCol IS NULL OR kcu.COLUMN_NAME <> @IdentityCol )
    )
    SELECT @pkCols = STUFF((
        SELECT ',' + QUOTENAME(PKU.COLUMN_NAME)
        FROM PKU
        FOR XML PATH(''), TYPE).value('.','nvarchar(max)'),1,1,''
    );

    -------------------------------------------------------------------------
    -- Résultats (une ligne par ligne du batch)
    -------------------------------------------------------------------------
    DECLARE @out TABLE (
        RowIndex    INT,
        NewID       NVARCHAR(100),
        ErrorMessage NVARCHAR(MAX)
    );

    -------------------------------------------------------------------------
    -- Découpage du batch "à la main" (compat. SQL 2016, sans STRING_SPLIT)
    -------------------------------------------------------------------------
    IF @ValuesBatch IS NULL OR LEN(@ValuesBatch)=0
    BEGIN
        INSERT INTO @out(RowIndex, NewID, ErrorMessage)
        VALUES(0,NULL,N'Batch vide (aucune donnée)');
        SELECT RowIndex, NewID, ErrorMessage FROM @out ORDER BY RowIndex;
        RETURN;
    END

    DECLARE @len   INT  = LEN(@ValuesBatch);
    DECLARE @cur   INT  = 1;              -- position courante dans @ValuesBatch
    DECLARE @next  INT;                   -- position du prochain @RS
    DECLARE @line  NVARCHAR(MAX);         -- ligne courante (une ligne du batch)
    DECLARE @i     INT = 1;               -- RowIndex (1..N)

    -- Préparer les colonnes avec ordre
    DECLARE @cols TABLE(ColName nvarchar(128), Ord int);
    INSERT INTO @cols(ColName, Ord)
    SELECT LTRIM(RTRIM(REPLACE(REPLACE(Item,'[',''),']',''))) AS ColName, Ord
    FROM dbo.SplitByCommaOrdered(@Columns);

    -- Préparer l'ensemble des colonnes PK (table pour test IN rapide)
    DECLARE @pk TABLE(ColName nvarchar(128) PRIMARY KEY);
    IF @pkCols IS NOT NULL AND LEN(@pkCols)>0
    BEGIN
        INSERT INTO @pk(ColName)
        SELECT LTRIM(RTRIM(REPLACE(REPLACE(Item,'[',''),']','')))
        FROM dbo.SplitByCommaOrdered(@pkCols);
    END

    WHILE @cur <= @len
    BEGIN
        -- Isoler la ligne suivante
        SET @next = CHARINDEX(@RS, @ValuesBatch, @cur);
        IF @next = 0
            SET @line = SUBSTRING(@ValuesBatch, @cur, @len - @cur + 1);
        ELSE
            SET @line = SUBSTRING(@ValuesBatch, @cur, @next - @cur);

        -- Avancer le curseur
        IF @next = 0
            SET @cur = @len + 1;
        ELSE
            SET @cur = @next + 1;

        -- Trim de sécurité
        SET @line = LTRIM(RTRIM(@line));

        -- Ignorer les lignes vides
        IF @line IS NULL OR LEN(@line)=0
        BEGIN
            INSERT INTO @out(RowIndex, NewID, ErrorMessage)
            VALUES(@i,NULL,N'Ligne vide ignorée');
            SET @i += 1;
            CONTINUE;
        END

        ---------------------------------------------------------------------
        -- 1) Vérifier nb valeurs vs nb colonnes (compte des @CS + 1)
        ---------------------------------------------------------------------
        DECLARE @valCount INT = (LEN(@line) - LEN(REPLACE(@line, @CS, N''))) + 1;
        DECLARE @colCount INT = (LEN(@Columns) - LEN(REPLACE(@Columns, N',', N''))) + 1;

        IF @valCount <> @colCount
        BEGIN
            INSERT INTO @out(RowIndex, NewID, ErrorMessage)
            VALUES(@i,NULL,
                   N'ERR: Nombre de valeurs <> colonnes. Attendu='
                   + CAST(@colCount AS nvarchar(10))
                   + N' | Trouvé=' + CAST(@valCount AS nvarchar(10))
                   + N' | Row="' + @line + N'"');
            SET @i += 1;
            CONTINUE;
        END

        ---------------------------------------------------------------------
        -- 2) Détection de doublon si PK/UK
        ---------------------------------------------------------------------
        DECLARE @whereClause nvarchar(max) = N'';

        IF EXISTS(SELECT 1 FROM @pk)
        BEGIN
            DECLARE @ord int = 1, @p int = 1, @n int, @token nvarchar(max);
            DECLARE @work nvarchar(max) = @line;

            WHILE 1=1
            BEGIN
                SET @n = CHARINDEX(@CS, @work, @p);
                IF @n = 0 SET @token = SUBSTRING(@work, @p, LEN(@work)-@p+1);
                ELSE      SET @token = SUBSTRING(@work, @p, @n-@p);

                DECLARE @col nvarchar(128) =
                    (SELECT ColName FROM @cols WHERE Ord=@ord);

                IF @col IS NOT NULL AND EXISTS(SELECT 1 FROM @pk WHERE ColName=@col)
                BEGIN
                    SET @whereClause = @whereClause
                        + CASE WHEN LEN(@whereClause)>0 THEN N' AND ' ELSE N'' END
                        + QUOTENAME(@col) + N' = '
                        + CASE WHEN UPPER(LTRIM(RTRIM(@token))) = N'NULL'
                               THEN N'NULL' ELSE @token END;
                END

                SET @ord = @ord + 1;
                IF @n = 0 BREAK;
                SET @p = @n + 1;
            END

            IF LEN(@whereClause) > 0
            BEGIN
                DECLARE @exists bit = 0;
                DECLARE @checkSql nvarchar(max) =
                    N'SELECT @out = CASE WHEN EXISTS (SELECT 1 FROM '
                    + QUOTENAME(@TableName) + N' WITH (NOLOCK) WHERE '
                    + @whereClause + N') THEN 1 ELSE 0 END';
                EXEC sp_executesql @checkSql, N'@out bit OUTPUT', @out=@exists OUTPUT;

                IF @exists = 1
                BEGIN
                    INSERT INTO @out(RowIndex, NewID, ErrorMessage)
                    VALUES(@i, NULL, N'Doublon');
                    SET @i += 1;
                    CONTINUE;
                END
            END
        END

        ---------------------------------------------------------------------
        -- 3) Construire la liste @values pour l’INSERT
        --    (remplacement du séparateur colonnes par des virgules)
        ---------------------------------------------------------------------
        DECLARE @values nvarchar(max) = REPLACE(@line, @CS, N',');

        ---------------------------------------------------------------------
        -- 4) Construire & exécuter l’INSERT
        ---------------------------------------------------------------------
        DECLARE @sql nvarchar(max) =
            N'INSERT INTO ' + QUOTENAME(@TableName) + N' (' + @Columns + N') ';

        IF @HasIdentity = 1 AND @IdentityCol IS NOT NULL
            SET @sql += N'OUTPUT INSERTED.' + QUOTENAME(@IdentityCol) + N' AS NewID ';
        SET @sql += N'SELECT ' + @values;

        BEGIN TRY
            IF @HasIdentity = 1 AND @IdentityCol IS NOT NULL
            BEGIN
                DECLARE @tmp TABLE(NewID nvarchar(100));
                INSERT INTO @tmp EXEC sp_executesql @sql;

                INSERT INTO @out(RowIndex, NewID, ErrorMessage)
                SELECT @i, NewID, NULL FROM @tmp;
            END
            ELSE
            BEGIN
                EXEC sp_executesql @sql;
                INSERT INTO @out(RowIndex, NewID, ErrorMessage)
                VALUES(@i, NULL, NULL);
            END
        END TRY
        BEGIN CATCH
            INSERT INTO @out(RowIndex, NewID, ErrorMessage)
            VALUES(@i, NULL, N'ERR: ' + ERROR_MESSAGE() + N' | vals=' + @values);
        END CATCH

        SET @i += 1;
    END -- while lignes

    -------------------------------------------------------------------------
    -- Retour
    -------------------------------------------------------------------------
    SELECT RowIndex, NewID, ErrorMessage
    FROM @out
    ORDER BY RowIndex;
END
GO