public void PerformMigration()
{
    Console.WriteLine("=== MIGRATION START ===");

    // 1) Tables (déjà filtrées par GetAllTables)
    var allTables = GetAllTables(); 

    // 2) Partition 
    LoadRelationTables(allTables, out var normalTables, out var extendedRelations, out var pureRelations);

    // 3) Dépendances & cycles (SCC)
    var fkMap = GetForeignKeysByTable(allTables); 
    var plan = BuildPlan(normalTables, extendedRelations, fkMap);

    // 4) Transaction globale 
    ExecuteTransactionCommand("BEGIN TRANSACTION");
    try
    {
        // 4.1) Parents (ordre topologique + cycles gérés par FK différées)
        foreach (var step in plan.NormalOrder)
        {
            var nullCols = plan.DeferredFkByTable.TryGetValue(step, out var set) ? set : null;
            ImportTableCommon(step, forceNullFK: false, batchSize: 500, nullFkColumns: nullCols);
        }
        // Fix-up des FK différées (celles mises à NULL dans les cycles)
        foreach (var kv in plan.DeferredFkByTable)
            FixupDeferredForeignKeys(kv.Key, kv.Value);

        // 4.2) Relations étendues (mêmes règles que parents, mais après eux)
        var orderedExtended = OrderTablesByDependencies(plan.ExtendedOrder, plan.DeferredFkByTable);
        foreach (var rel in plan.ExtendedOrder)
        {
            var nullCols = plan.DeferredFkByTable.TryGetValue(rel, out var set) ? set : null;
            ImportTableCommon(rel, forceNullFK: false, batchSize: 500, nullFkColumns: nullCols);
            if (nullCols != null && nullCols.Count > 0)
                FixupDeferredForeignKeys(rel, nullCols);
        }

        // 4.3) Relations pures (FK–FK, pas d’IDENTITY). On boucle jusqu’à stabilisation.
        ImportPureRelationsUntilStable(pureRelations);

        ExecuteTransactionCommand("COMMIT TRANSACTION");
    }
    catch (Exception ex)
    {
        Console.WriteLine("[FATAL] " + ex.Message);
        ExecuteTransactionCommand("ROLLBACK TRANSACTION");
        throw;
    }

    Console.WriteLine("=== MIGRATION DONE ===");
}
