// ---- NORMALISATION NOT NULL (double filet via DynamicSql) ----
var meta = GetColumnsMetaCached(tableName); // doit renvoyer un dict OrdinalIgnoreCase

foreach (var col in columnNames)
{
    if (hasIdentity && col.Equals(identityColumn, StringComparison.OrdinalIgnoreCase)) continue;
    if (!row.ContainsKey(col)) continue;

    meta.TryGetValue(col, out var m);                    // m peut être null
    if (m?.IsComputed == true) continue;                 // colonnes calculées: on n'insère pas

    var s = (row[col] ?? "").ToString();
    var isNullish = string.IsNullOrWhiteSpace(s) || s.Equals("NULL", StringComparison.OrdinalIgnoreCase);

    // Décide la nullabilité : méta -> vérif SQL (DynamicSql) en filet de sécurité
    bool isNullable = m?.IsNullable ?? true;
    if (isNullable)                                      // si la méta dit nullable, on confirme côté SQL
        isNullable = IsColumnNullableSql(tableName, col);

    if (isNullish)
    {
        if (!isNullable)
        {
            if (m != null && TryParseSimpleDefault(m.ColumnDefault, out var defVal))
                row[col] = defVal;                       // DEFAULT littéral
            else
                row[col] = GetTypeFallback(m?.DataType); // fallback typé (évite l'échec)
        }
        else
        {
            row[col] = null;                             // vraie valeur NULL autorisée
        }
    }
}
// ---- fin normalisation ----